(module
  (import io)
  (import random)

	(define-datatype values-t
	;;Value x y
	(Value float float))

	; Col value on matrix
	(define (read-matrix f)
    	(let* ((v1 (file-read-float f))
           (v2 (file-read-float f)))
       (Value v1 v2)))
	
	(define (dummyread)
	(Value 0.0 0.0))
	
	(define (setval a b)
	(Value a b))

	(define (reader)
	  (let ((f (file-open "AllRandom.mtx" )))
	        (let ((row (file-read-int f)))
		(let ((col (file-read-int f)))
		 (println* "Reading " col " lines.")
		  (let ((matrix (make-vector col (dummyread))))
                   (for(i 0 col) 
		      (set! (vector-ref matrix i) (read-matrix f))
		    )
	  (file-close f)
          ;;The above code is what is required to read a file of .mtx format with row col \n value value \n value value ... row is however omitted here
	  matrix)))));)

	 (define (readerCol)
	  (let ((f (file-open "AllRandom.mtx" )))
	  (let ((row (file-read-int f)))
	  (let ((col (file-read-int f)))
          (file-close f)
	 col))))

        (define (NormalVectorCalc matvec)
          (match matvec ;;match to a type
	   ((Value v1 v2)
            (let(( val (* v1 v1))(val2 (* v2 v2)))
	(+ val val2)))))

	(define (normalvector matvec col)
	  (let ((normalVector (make-vector col 1)))
                   (for(i 0 col) 
		      (set! (vector-ref normalVector i) (NormalVectorCalc (vector-ref matvec i)))
		    )
	normalVector))

	(define (VectorInit)
	(Value 0.0 0.0))

	(define (ConceptVectorInit col)
	  (let ((cVector (make-vector col (VectorInit))))
                   (for(i 0 col) 
		      (set! (vector-ref cVector i) (VectorInit))
		    )
	cVector))

	(define (SingleArray col)
	  (let ((cVector (make-vector col 1)))
                   (for(i 0 col) 
		      (set! (vector-ref cVector i) 0)
		    )
	cVector))

	(define (FloatArray col)
	  (let ((cVector (make-vector col 1)))
                   (for(i 0 col) 
		      (set! (vector-ref cVector i) 0.0)
		    )
	cVector))

	(define (getData vector i)
          (match vector ;;match to a type
	   ((Value v1 v2)
        (if(< i 1) v1 v2))))

	(define (AddRandom r cV col);;to be used once...
          (match (random r)
          ((RandomResult n r)
            (set! (vector-ref cV 0) (mod n col))
          ;(println* "the random in col is: " (mod n col));;debug
	cV)))

	(define (VectorAddition vec1 vec2)
	 (let((v1 (+ (getData vec1 0) (getData vec2 0))) (v2(+ (getData vec1 1) (getData vec2 1))))
	(Value v1 v2)))	

	(define (IthAddCV i cv matvec)
	   (VectorAddition cv (vector-ref matvec i)))

	(define (EucDistance x1 x2 v1 v2 norm normalVector)
	  (let((result0(* x1 v1))(result1(* x2 v2)))
	   (let((normresult(+ normalVector norm)))
	    (let((result2(+ result0 result1)))
	    (let((result4(* result2 -2.0)))  
	(+ result4 normresult))))))

	(define (PreEucDistance sim data normal normalVector mat)
	(match data
	((Value data1 data2)
	(match mat
	((Value val1 val2)	 
         (EucDistance data1 data2 val1 val2 normal normalVector) )))))

	(define (EucDis result normal data col normalVector mat cluster)
	   (for(i 0 col)
	     (set! (vector-ref result (* i cluster)) (PreEucDistance result data normal normalVector mat) )	
	   )
		result)

	;;                 sim i inputvector conceptvector col normalvector values
	(define (PreEucDis result i normal data col normalVector mat cluster)
	    	(EucDis result (vector-ref normal i) (vector-ref data i) col (vector-ref normalVector i) (vector-ref mat i) cluster))

	(define (setVectorData vectordat i vectorData)
	   (set! (vector-ref vectordat i) vectorData )
        vectordat)

	(define (averageVector val num);(vector-ref conceptVector i) (vector-ref clusterpointer i)
	 (match val
	 ((Value v1 v2)
	 (let( (t1 (/ v1 num)) (t2 (/ v2 num) ))
	(Value t1 t2) ))))

	(define (ClusterSize pointsinCluster clusterpointer clusterint col)
	  (set! pointsinCluster (FloatArray clusterint))
	  (for(i 0 col)
	    (set! (vector-ref pointsinCluster (vector-ref clusterpointer i)) (+ (vector-ref pointsinCluster (vector-ref clusterpointer i)) 1) )
	  )
	pointsinCluster)

	(define (norm2 vec)
	(match vec
	((Value v1 v2)
	(let( (t1 (* v1 v1)) (t2 (* v2 v2)) )
	(+ t1 t2) ))))

	(define (clusterQ CQ clusterPointer i simMat)
	  (set! (vector-ref CQ clusterPointer) (vector-ref simMat (* (+ clusterPointer 1) i) ) )
	CQ)

	(define (Coherence clusterInt CQ)
	(let((value 0.0) )
	(for(i 0 clusterInt)
	 (set! value (+ (vector-ref CQ i) value)) )	
	value))

	(define (Kmeans-Algorithm mat clusterint col normalVector result conceptVector simMat cV normalCV pointsinCluster clusterpointer clusterquality initialobjval threshold)
	 (let((niter 0) (noassign #t) (pre_result 0.0) (eststart 5) )
	 (let((multi 0) (tempCluster 0) (tempSim 0) (changed 0) (difference (FloatArray clusterint)))
	;;as there is no do while all code will be repeated before the while
	 (while (> (- pre_result result) (* initialobjval 0.001))
	   (set! pre_result result)
	   (set! niter (+ niter 1))
	   ;;ASSIGN START
	  
	  (for(i 0 clusterint)
	    (for(j 0 col)
	      (if(= i (vector-ref clusterpointer j)) 0 (set! (vector-ref simMat (* (+ i 1) j)) (- (vector-ref difference i) (* 2 (* (sqrt (vector-ref difference i)) (sqrt (vector-ref simMat (* (+ i 1) j))) ))    )      )   )
	  ) )
	   
	  (for(i 0 col)
	    (for(j 0 clusterint)
	      (if(= j (vector-ref clusterpointer i)) 0 (set! multi (+ multi 1)) )
	      (if(= j (vector-ref clusterpointer i)) 0 (set! (vector-ref simMat (* i (+ j 1))) (PreEucDistance simMat (vector-ref conceptVector j) (vector-ref normalCV j) (vector-ref normalVector i) (vector-ref mat i) ) ) )
	      (if(= j (vector-ref clusterpointer i)) 0 (if(< (vector-ref simMat (* i (+ j 1))) tempSim) (set! tempCluster j)) )	      
	      (if(= j (vector-ref clusterpointer i)) 0 (if(< (vector-ref simMat (* i (+ j 1))) tempSim) (set! tempSim (vector-ref simMat (* i (+ j 1))))) )
	    ) 
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! (vector-ref simMat (* (+ tempCluster 1) i)) tempSim) )
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! changed (+ changed 1)) ) 
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! (vector-ref clusterpointer i) tempCluster) )
	  )
	  ;; ASSIGN END
	
	  (set! noassign #f)
	  
	  ;;UpdateCentroid
	  (set! conceptVector (ConceptVectorInit clusterint) )
	  (for(i 0 col)
	    (set! (vector-ref conceptVector (vector-ref clusterpointer i)) (IthAddCV i (vector-ref conceptVector (vector-ref clusterpointer i)) mat )   )
	  )
	  ;;updateCentroid DONE
	  
	 ;  (if() 0 (for(one 0 1)
	 ;))
         )
	
	0)))

	(define (main)
	  (let((mat (reader)));;now the Matrix is loaded
	  (println* "first line: " (vector-ref mat 0) )
          (let((clusterint 4))
	  (let((col(readerCol))) ;; col is set
	  (println* "col value is: " col)
	  (let((normalVector ( normalvector mat col)));; normal vector calculated
	  (println* "first normalvector: " (vector-ref normalVector 0) )
	  (let((nVzero(vector-ref normalVector 0)))
	  (let((conceptVector ( ConceptVectorInit clusterint)));; Conceptvector init
          (println* "first conceptVector: " (vector-ref conceptVector 0) )
	  ;;Will handle the simMat with an offset instead
	  (let((simMat ( FloatArray (* col clusterint))));; Conceptvector init
          (println* "first conceptVector: " (vector-ref simMat 0) )
 	  (let((cV (SingleArray clusterint))) ;;addrandom clustervector 4 clusters
          (println* "first cV: " (vector-ref cV 0) )

	  (let((cV (AddRandom (init-rand) cV col)))
	  (set! (vector-ref conceptVector 0) (IthAddCV (vector-ref cV 0) (vector-ref conceptVector 0) mat)))
	  (println* "get Data test" (getData (vector-ref mat 0) 1))
	  ;;timer should be inserted when the Kmeans algorithm actually starts.
	  (let((normalCV (FloatArray col))) ;; init normal_cv
          (println* "first cV: " (vector-ref cV 0) " still working ?" )
	  (let((normalCV (setVectorData normalCV 0 nVzero)))
	  (let((simMat (PreEucDis simMat 0 normalCV conceptVector col normalVector mat 1)))
	  (let((pointsinCluster (FloatArray clusterint)))
	  
	  (let((minind 0) (mind 0)(cossum 0))

	  (for(i 0 clusterint)
	    (set! minind 0)
	    (set! mind 0)
	    (for(j 0 col)
	      (set! cossum 0)
	      (for(k 0 i)
	        (+ cossum (vector-ref simMat (* j (+ k 1))))
	      )
	      (if(> cossum mind)
	       (set! mind cossum))
	      (if(> cossum mind)
	       (set! minind j))
	    )
	    (set! (vector-ref cV i) minind)
	    (set! (vector-ref conceptVector i) (IthAddCV (vector-ref cV i) (vector-ref conceptVector i) mat))
	    (set! (vector-ref normalCV i) (vector-ref normalVector (vector-ref cV i)))
	    (set! simMat (PreEucDis simMat i normalCV conceptVector col normalVector mat (+ i 1)))
	  ) 

	(let((clusterpointer(SingleArray col)))
	  ;InitAssignCluster as I cannot find where to return multiple data without the need to split them afterwards I will make them in main but not optimal. changed is for later just implemented now to copy paste
          (println* "We are still alive before assign")
	  (let((multi 0) (tempCluster 0) (tempSim 0) (changed 0))

	  (for(i 0 col)
	    (for(j 0 clusterint)
	      (if(= j (vector-ref clusterpointer i)) 0 (set! multi (+ multi 1)) )
	      (if(= j (vector-ref clusterpointer i)) 0 (if(< (vector-ref simMat (* i (+ j 1))) tempSim) (set! tempCluster j)) )	      
	     (if(= j (vector-ref clusterpointer i)) 0 (if(< (vector-ref simMat (* i (+ j 1))) tempSim) (set! tempSim (vector-ref simMat (* i (+ j 1))))) )
	    ) 
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! (vector-ref simMat (* (+ tempCluster 1) i)) tempSim) )
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! changed (+ changed 1)) ) 
	    (if(= (vector-ref clusterpointer i) tempCluster ) 0 (set! (vector-ref clusterpointer i) tempCluster) )
	  )
	(println* "still alive after assignment" )

	;last of initial, resetting and extra methods
	(set! conceptVector ( ConceptVectorInit col))

	(for(i 0 col)
	  (if(>= (vector-ref clusterpointer i) 0) (if(< (vector-ref clusterpointer i) clusterint) (set! (vector-ref conceptVector (vector-ref clusterpointer i)) (IthAddCV i (vector-ref conceptVector (vector-ref clusterpointer i)) mat)) (set! (vector-ref clusterpointer i)0 )) )
	)
	(println* "still alive 1" )
	(set! pointsinCluster(ClusterSize pointsinCluster clusterpointer clusterint col))

	(for(i 0 clusterint)
	 (set! (vector-ref conceptVector i) (averageVector (vector-ref conceptVector i) (vector-ref pointsinCluster i) ))  
	)
	(println* "still alive 2" )
	(for(i 0 clusterint)
	  (set! (vector-ref normalCV i) (norm2 (vector-ref conceptVector i)))
	)
	(println* "still alive 3" )
	(for(i 0 clusterint)
	  (set! simMat (PreEucDis simMat i normalCV conceptVector col normalVector mat 1))
	)
	(println* "still alive 4" )
	(let( (clusterquality (FloatArray clusterint)) (k 0))
	(println* "still alive 5" )
	(for(i 0 col)
	  (set! k (vector-ref clusterpointer i))
	  (set! clusterquality (clusterQ clusterquality k i simMat) )
	)
	(println* "still alive 6" )
	(let( (initialobjval (Coherence clusterint clusterquality)) (result (Coherence clusterint clusterquality)) (delta 0.000001) )
	(let( (threshold (*(* -1.0 initialobjval) delta))   )

	(Kmeans-Algorithm mat clusterint col normalVector result conceptVector simMat cV normalCV pointsinCluster clusterpointer clusterquality initialobjval threshold)

	0))))))))) )))))) ) )) ) ));;the weird spacing is just to have control over how many parenthesis that have been used.

)
